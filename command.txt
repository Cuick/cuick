








============================================================
         ★ 学习链接 ★
============================================================

http://www.jianshu.com/notebooks/293635/latest   django + pure

上文作者博客
http://andrewliu.in/

====
twisted：
http://blog.chinaunix.net/uid-7684977-id-2569706.html
https://my.oschina.net/1123581321/blog/160654
======

http://mclspace.com/
http://www.cnblogs.com/fakis/
http://bbs.c114.net/thread-880707-1-1.html 面试经历
http://www.acmerblog.com/ acm比赛
http://www.oschina.net/project/zh/ 开源项目国内
http://python.ctolib.com/
http://www.cnblogs.com/Wayou/p/requestAnimationFrame.html   html5跑车原理
http://developer.egret.com/cn/ HTML5 引擎
http://bbs.zzfriend.com/thread-2738-1-1.html  html5 打飞机
http://www.itmian4.com/forum.php?mod=viewthread&tid=7774&_dsign=4c0bb21e 书单
http://www.csdn.net/article/2014-10-27/2822292-how-league-of-legends-scaled-chat-to-70-million-players eralng LOL700万在线chat服务器
http://blog.csdn.net/neil3d/article/details/39104329 炉石传说
https://toutiao.io/ 开发者头条
http://www.kuqin.com/shuoit/20151105/348778.html docker
ejabberd是基于Jabber/XMPP协议的即时通讯服务器，由GPLv2授权（免费和开放源码），采用Erlang/OTP开发。它的特点是，跨平台，容错，集群和模块化
http://www.wklken.me/posts/2013/08/18/python-extra-functools.html python functools模块
http://www.cnblogs.com/qq78292959/archive/2012/05/08/2490443.html  ulimit

http://www.wklken.me/posts/2013/08/17/130-essential-vim-commands.html vim技巧

===========================================================

ngrok  内网穿透
WooYun 网络安全相关










============================================================
         项目
============================================================
hget stat:2:2016-10-10 in.diamond*
主播号：400 sdiff 'game.2.live.telecast.user'
barrel_level 54
pay_total 10000
hmset props:2:20040 201 10000 202 10000 203 10000 204 10000 205 10000 206 10000 208 10000 209 10000 210 10000 211 10000 212 10000 213 10000 214 10000 215 10000 216 10000 217 10000 218 10000 219 10000 220 10000
hmset game:2:20040 chip 100000000 diamond 10000000

================


1. 初级场、中级场钻石获得上限调整为500

2. 掉落道具和钻石概率提高至30%

3. 新用户第一次抽奖必中蛋（当用户奖池够抽蛋时）（半天）

4. 新用户打普通BOSS掉蛋，第一次必掉1铜蛋（半天）

5. 非付费新手保护：打到分数1W以下，增加爆率200%，直至分数上涨到5W，爆率恢复正常，每个新用户有两次机会
付费新手保护：打到分数1W以下，增加爆率200%，直至分数上涨只充值金额*2W，每个新用户限前三笔充值（可累计），最高限额1000W（两天）

别的渠道消耗金币
别的渠道获得金币


6. 新用户签到：（一天）
第一天奖励不变  第二天奖励钻石*100  第三天奖励铜蛋*1 第四天奖励不变
第五天奖励银蛋*1 第六天奖励不变第七天奖励金蛋*1






===========================================================

★ script/game.sh
readlink 获取文件或目录绝对路径
dirname 获取文件或目录所在的目录

ulimit -c unlimited 设置core文件大小为不限制大小

$0 Shell本身的文件名
$1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…
$$ Shell本身的PID（ProcessID）
$! Shell最后运行的后台Process的PID
$? 最后运行的命令的结束代码（返回值）
$- 使用Set命令设定的Flag一览
$* 所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有数。
$@ 所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$# 添加到Shell的参数个数









===========================================================
                     ★ linux ★
===========================================================
grep 219.*on_resolve_st
one *2016-09-09

grep '219.*present.props' bi-*2016-09-09 > zzz.txt

echo "" > aa && curl -d '{"userId":20001,"chip":3224,"gameId":2,"token":"aXh4b28ubWVAZ21haWwuY29tCg=="}' "http://192.168.1.35:19000/v1/shell/reward/chip" >> aa && cat aa

tar -zcvf hello.tar.gz hello.txt
tar -zxf niuniu.tar.gz

★ 删除项目下所有svn文件
find . -type d -name ".svn"|xargs rm -rf

★ ssh反向连接

★ ngrok

★ 目录结构

Unix（包含Linux）的初学者，常常会很困惑，不明白目录结构的含义何在。

举例来说，根目录下面有一个子目录/bin，用于存放二进制程序。但是，/usr子目录下面还有/usr/bin，以及/usr/local/bin，也用于存放二进制程序；某些系统甚至还有/opt/bin。它们有何区别？

长久以来，我也感到很费解，不明白为什么这样设计。像大多数人一样，我只是根据《Unix文件系统结构标准》（Filesystem Hierarchy Standard），死记硬背不同目录的区别。

昨天，我读到了Rob Landley的简短解释，这才恍然大悟，原来Unix目录结构是历史造成的。

话说1969年，Ken Thompson和Dennis Ritchie在小型机PDP-7上发明了Unix。1971年，他们将主机升级到了PDP-11。

当时，他们使用一种叫做RK05的储存盘，一盘的容量大约是1.5MB。

没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘RK05，并且规定第一块盘专门放系统程序，第二块盘专门放用户自己的程序，因此挂载的目录点取名为/usr。也就是说，根目录”/”挂载在第一块盘，”/usr”目录挂载在第二块盘。除此之外，两块盘的目录结构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp…）都在/usr目录下重新出现一次。

后来，第二块盘也满了，他们只好又加了第三盘RK05，挂载的目录点取名为/home，并且规定/usr用于存放用户的程序，/home用于存放用户的数据。

从此，这种目录结构就延续了下来。随着硬盘容量越来越大，各个目录的含义进一步得到明确。

/：存放系统程序，也就是At&t开发的Unix程序。

/usr：存放Unix系统商（比如IBM和HP）开发的程序。

/usr/local：存放用户自己安装的程序。

/opt：在某些系统，用于存放第三方厂商开发的程序，所以取名为option，意为”选装”。


===========================================================
          vim
===========================================================


1) 文件内全部替换：

:%s#abc#123#g (如文件内有#，可用/替换,:%s/abc/123/g)
  --注：把abc替换成123

(或者: %s/str1/str2/g 用str2替换文件中所有的str1）

2) 文件内局部替换：

 :20,30s#abc#123(如文件内有#，可用/替换,:%s/abc/123/g)
  --注：把20行到30行内abc替换成123



============================================================
                     ★ python ★
============================================================


计算md5
>>>> import hashlib
>>>> m=hashlib.md5()
>>>> m.update('\xe5\xb0\x8f\xe8\x82\x9b\xe8\x82\x9b123456')
>>>> m.hexdigest()

反射
自省


============================================================
                      ★ redis ★                         
============================================================



127.0.0.1:16400> hgetall "username:11:\xe5\xb0\x81\xe9\x94\x81\xe6\x88\x91\xe4\xb8\x80\xe7\x94\x9f"

redis-cli -p 16400
hgetall "username:11:\xe5\xb0\x8f"
redis-cli -p 16401
hgetall "order:10020001BwNcnDhU"
redis-cli -p 16380
hgetall user:86056





============================================================
                     ★ git ★
============================================================

先 git clone 整个仓库，然后 git checkout tag_name 就可以取得 tag 对应的代码了。

但是这时候 git 可能会提示你当前处于一个“detached HEAD" 状态，因为 tag 相当于是一个快照，是不能更改它的代码的，如果要在 tag 代码的基础上做修改，你需要一个分支：

?
1
git checkout -b branch_name tag_name
这样会从 tag 创建一个分支，然后就和普通的 git 操作一样了。



============================================================
cha.py

import redis

f = file("hello.txt", "a+")
# for uid in range(20001, 20010):
for uid in range(20001, 164193):
    data = '%s,' % uid
    port = uid % 8 + 16380
    r = redis.Redis(host='localhost', port=port, db=0)
    # r = redis.Redis(host='localhost', port=6379, db=2)
    b = r.hmget('game:2:%s' % uid, ['exp', 'chip', 'in_chip', 'out_chip',
                                    'diamond', 'in_diamond', 'out_diamond',
                                    'barrel_level', 'pay_total',
                                    'session_login', 'block'])
    if not b[8]:
        continue
    a = r.hmget('user:%s' % uid, ['createTime', 'channel'])
    c = r.hmget('props:2:%s' % uid, ['201', '202', '211', '212',
                                     '213', '214'])
    for ind, v in enumerate(c):
        if not v:
            c[ind] = ''
    for ind, v in enumerate(b):
        if not v:
            b[ind] = ''
    data = '%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n' \
        % (uid, a[0], b[0], b[1], b[2], b[3], b[4], b[5],
           b[6], b[7], b[8], b[9], b[10], c[0], c[1], c[2], c[3], c[4], c[5])
    f.write(data)
    print uid
f.close()

=======

dia.py

import redis

f = file("hello.txt", "a+")
r = redis.Redis(host='localhost', port=16402, db=0)
b = r.hgetall('stat:2:2016-10-10')
print b
all = 0
for k, v in b.items():
    if 'in.diamond.' in k:
        f.write('%s %s\n' % (k, v))
        all += int(v)
f.write('all %s\n' % all)

f.close()

==========

max_chip.py

import redis
import datetime
import time

fmt = '%Y-%m-%d %X'
# t1 = datetime.datetime.strptime('2016-10-22 00:00:01', fmt).timetuple()
# tt1 = int(time.mktime(t1))
r = redis.Redis(host='localhost', port=16400, db=0)
max_uid = int(r.hget('global.info.hash', 'max.user.id'))

f = file("max_chip.txt", "a+")
for x in [0, 1, 2, 3, 4, 5, 6, 7]:
    port = x + 16380
    r = redis.Redis(host='localhost', port=port, db=0)
    for uid in range(20001, max_uid):
        # port = uid % 8 + 16380
        b = r.hmget('game:2:%s' % uid, ['exp', 'chip', 'in_chip', 'out_chip',
                                        'diamond', 'in_diamond', 'out_diamond',
                                        'barrel_level', 'pay_total',
                                        'session_login', 'block'])
        if not b[1] or int(b[1]) < 10000000:
            continue

        a = r.hmget('user:%s' % uid, ['createTime', 'channel'])
        if not a[0]:
            continue
        # t = datetime.datetime.strptime(a[0][:19], fmt).timetuple()
        # tt = int(time.mktime(t))
        # if tt < tt1:
        #     continue

        c = r.hmget('props:2:%s' % uid, ['201', '202', '211', '212',
                                         '213', '214'])
        for ind, v in enumerate(c):
            if not v:
                c[ind] = ''
        for ind, v in enumerate(b):
            if not v:
                b[ind] = ''
        data = '%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n' \
            % (uid, a[0], a[1], b[0], b[1], b[2], b[3], b[4], b[5],
               b[6], b[7], b[8], b[9], b[10], c[0], c[1], c[2], c[3], c[4], c[5])
        f.write(data)
        print uid
f.close()


============================================================
★ 三种应该知道的技能

1.期望价值管理。少吹牛逼多干实事。制造能力假象容易提高他人对自己过分的期望，所谓爬的高，摔得重。
2.阀值自控意识。对任何喜欢的东西要有“节欲”意识。喜欢吃的东西不要一次吃个尽兴，喜欢听的歌曲也不要单曲循环没完没了。所谓细水长流，把“快感”变成“慢感”，好东西才能长久。
3.应对时空扭曲。努力让自己的生活产生变化，不断进步，旅游交友，增加人生的宽度，使自己的生命经历更多，体验更多。


======================================================================
★ 文件系统

1、什么是文件系统

2、文件系统的类型

3、目录结构的详细解读

4、一些重要子目录的解读

5、附录：目录结构的简明查阅手册


1、什么是文件系统

 

当您使用Linux的时候，如果您通过ls Cl / 就会发现，在/下包涵很多的目录，比如etc、usr、var、bin ... ... 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为树形结构。

linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。

 

2、文件系统的类型

 

LINUX有四种基本文件系统类型：普通文件、目录文件、连接文件和特殊文件，可用file命令来识别。

 

普通文件：如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。

 

目录文件：包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件。

 

连接文件：是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以"->"指向所连接的文件。

 

特殊文件：LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。

 

3、目录结构的详细解说

 

文件系统的组织结构分析，我们能分析什么呢？也就是当我们列/目录时，所看到的/usr、/etc ... ... /var 等目录是做什么用的，这些目录是不是有些特定的用途。无论哪个哪个版本的Linux系统，都有这些目录，这些目录应该是标准的。当然各个Linux发行版本也会存在一些小小的差异，但总体来说，大体还是差不多。

言归正传，下面飘扬将讲到本文最核心的部分：linux文件系统的目录结构。

 

/ bLinux文件系统的入口，也是处于最高一级的目录；

/bin 系统所需要的那些命令位于此目录，比如 ls、cp、mkdir等命令；功能和/usr/bin类似，这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。

/boot Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；

/dev 设备文件存储目录，比如声卡、磁盘... ...

/etc 系统配置文件的所在地，一些服务器的配置文件也在这里；比如用户帐号及密码配置文件；

/home 普通用户家目录默认存放目录；

/lib 库文件存放目录

/lost+found 在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。

/mnt 这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎么定义了；比如光驱可以挂载到/mnt/cdrom 。

/opt 表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure --prefix=/opt/目录 。

/proc 操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。

/root Linux超级权限用户root的家目录；

/sbin 大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。

/tmp 临时文件目录，有时用户运行程序的时候，会产生临时文件。/tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。

/usr 这个是系统存放程序的目录，比如命令、帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts ，帮助目录 /usr/share/man或/usr/share/doc，普通用户可执行文件目录/usr/bin 或/usr/local/bin 或/usr/X11R6/bin ，超级权限用户root的可执行命令存放目录，比如 /usr/sbin 或/usr/X11R6/sbin 或/usr/local/sbin 等；还有程序的头文件存放目录/usr/include。

/var 这个目录的内容是经常变动的，看名字就知道，我们可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地；

 

4、一些重要子目录的解说

 

下面飘扬再补充几个比较常见且很重要的目录。

/etc/init.d 这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。比如Fedora/RedHat；

/etc/xinit.d 如果服务器是通过xinetd模式运行的，它的脚本要放在这个目录下。有些系统没有这个目录， 比如Slackware，有些老的版本也没有。在Rehat/Fedora中比较新的版本中存在。

/etc/rc.d 这是Slackware发行版有的一个目录，是BSD方式启动脚本的存放地；比如定义网卡，服务器开启脚本等。

/etc/X11 这是X-Windows相关的配置文件存放地。

 

/usr/bin 这个目录是可执行程序的目录，普通用户就有权限执行；当我们从系统自带的软件包安装一个程序时，他的可执行文件大多会放在这个目录。比如安装gaim软件包时。相似的目录是/usr/local/bin；有时/usr/bin中的文件是/usr/local/bin的链接文件；

/usr/sbin 这个目录也是可执行程序的目录，但大多存放涉及系统管理的命令。只有root权限才能执行；相似目录是/sbin 或/usr/local/sbin或/usr/X11R6/sbin等；

/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录。自己看看吧。

/usr/share 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。

/usr/src 是内核源码存放的目录，比如下面有内核源码目录，比如 linux 、linux-2.xxx.xx 目录等。有的系统也会把源码软件包安装在这里。比如Fedora/Redhat，当我们安装file.src.rpm的时候，这些软件包会安装在 /usr/src/redhat相应的目录中。

/var/adm 比如软件包安装信息、日志、管理信息等，在Slackware操作系统中是有这个目录的。在Fedora中好象没有；自己看看吧。

/var/log 系统日志存放，分析日志要看这个目录的东西；

/var/spool 打印机、邮件、代理服务器等假脱机目录；

 

5、附录：目录结构的简明查阅手册

 

(1)“/”根目录部分有以下子目录：

 

/usr 目录包含所有的命令、程序库、文档和其它文件。这些文件在正常操作中不会被改变的。这个目录也包含你的Linux发行版本的主要的应用程序，譬如，Netscape。

/var 目录包含在正常操作中被改变的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等

/home 目录包含用户的文件：参数设置文件、个性化文件、文档、数据、EMAIL、缓存数据等。这个目录在系统省级时应该保留。

/proc 目录整个包含虚幻的文件。它们实际上并不存在磁盘上，也不占用任何空间。（用ls Cl 可以显示它们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统

/bin 系统启动时需要的执行文件（二进制），这些文件可以被普通用户使用。

/sbin 系统执行文件（二进制），这些文件不打算被普通用户使用。（普通用户仍然可以使用它们，但要指定目录。）

/etc 操作系统的配置文件目录。

/root 系统管理员（也叫超级用户或根用户）的Home目录。

/dev 设备文件目录。LINUX下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享以及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目 录。这些设备的内容会出现在独立的子目录下。LINUX没有所谓的驱动符。

/lib 根文件系统目录下程序和核心模块的共享库。

/boot 用于自举加载程序（LILO或GRUB）的文件。当计算机启动时（如果有多个操作系统，有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX核（压缩文件vmlinuz），但LINUX核也可以存在别处，只要配置LILO并且LILO知道LINUX核在哪儿。

/opt 可选的应用程序，譬如，REDHAT 5.2下的KDE （REDHAT 6.0下，KDE放在其它的XWINDOWS应用程序中，主执行程序在/usr/bin目录下）

/tmp 临时文件。该目录会被自动清理干净。

/lost+found 在文件系统修复时恢复的文件

 

(2)“/usr”目录下比较重要的部分有：

/usr/X11R6 X-WINDOWS系统（version 11, release 6)

/usr/X11 同/usr/X11R6 （/usr/X11R6的符号连接）

/usr/X11R6/bin 大量的小X-WINDOWS应用程序（也可能是一些在其它子目录下大执行文件的符号连接）。

/usr/doc LINUX的文档资料（在更新的系统中，这个目录移到/usr/share/doc）。

/usr/share 独立与你计算机结构的数据，譬如，字典中的词。

/usr/bin和/usr/sbin 类似与“/”根目录下对应的目录（/bin和/sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。

/usr/local 本地管理员安装的应用程序（也可能每个应用程序有单独的子目录）。在“main”安装后，这个目录可能是空的。这个目录下的内容在重安装或升级操作系统后应该存在。

/usr/local/bin 可能是用户安装的小的应用程序，和一些在/usr/local目录下大应用程序的符号连接。

(3)“/proc”目录的内容：

/proc/cpuinfo 关于处理器的信息，如类型、厂家、型号和性能等。

/proc/devices 当前运行内核所配置的所有设备清单。

/proc/dma 当前正在使用的DMA通道。/proc/filesystems 当前运行内核所配置的文件系统。

/proc/interrupts 正在使用的中断，和曾经有多少个中断。

/proc/ioports 当前正在使用的I/O端口。








===========================================================
★ vim 替换

语法  :[addr]s/源字符串/目的字符串/[option]

全局替换命令   :%s/源字符串/目的字符串/g

[addr] 表示检索范围，省略时表示当前行。
如：“1，20” ：表示从第1行到20行；
“%” ：表示整个文件，同“1,$”；
“. ,$” ：从当前行到文件尾；
s : 表示替换操作

[option] : 表示操作类型
如：g 表示全局替换; 
c 表示进行确认
p 表示替代结果逐行显示（Ctrl + L恢复屏幕）；
省略option时仅对每行第一个匹配串进行替换；
如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义

下面是一些例子：
#将That or this 换成 This or that
:%s/\(That\) or \(this\)/\u\2 or \l\1/
―- 
#将句尾的child换成children
:%s/child\([ ,.;!:?]\)/children\1/g
―-
#将mgi/r/abox换成mgi/r/asquare
:g/mg\([ira]\)box/s//mg//my\1square/g    <=>  :g/mg[ira]box/s/box/square/g
―-
#将多个空格换成一个空格
:%s/  */ /g
―-
#使用空格替换句号或者冒号后面的一个或者多个空格
:%s/\([:.]\)  */\1 /g
―-
#删除所有空行
:g/^$/d
―-
#删除所有的空白行和空行
:g/^[  ][  ]*$/d
―-
#在每行的开始插入两个空白
:%s/^/>  /
―-
#在接下来的6行末尾加入.
:.,5/$/./
―-
#颠倒文件的行序
:g/.*/m0O  <=> :g/^/m0O
―-
#寻找不是数字的开始行,并将其移到文件尾部
:g!/^[0-9]/m$ <=> g/^[^0-9]/m$
―-
#将文件的第12到17行内容复制10词放到当前文件的尾部
:1,10g/^/12,17t$
~~~~重复次数的作用
―-
#将chapter开始行下面的第二行的内容写道begin文件中
:g/^chapter/.+2w>>begin
―-
:/^part2/,/^part3/g/^chapter/.+2w>>begin
―-
:/^part2/,/^part3/g/^chapter/.+2w>>begin|+t$


========================================================

★ 算法复杂度

时间复杂度：执行算法所需要的计算工作量
空间复杂度：执行这个算法所需要的内存空间


========================================================


成为一个主程还需要什么
架构脉络明白了，但是细节根本不熟悉。
继续研究这套服务器，并深入学习python。
twisted，stackless 实现
==
这几天发现，贪多的去学语言没有用，都只是学习了一些皮毛，只是学了些语法。
应该耐下心来 把手里在用的学扎实，

VR时代就要到了
全民VR的时候 新的创新机遇















